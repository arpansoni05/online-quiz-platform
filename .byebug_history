continue
answer_params[:correct].class
continue
answer_params[:correct].class
answer_params[:correct]
answer_params
params[:correct]
params
continue
n
@assessment
n
@assessment
continue
allocation
continue
n
params
continue
current_user.allocations
params[:assessment_id]
user_id
Allocation
score
allocation
continue
@assessment
current_user.allocations
current_user
a.allocations
a.allocation
a = params[:assessment_id]
params[:assessment_id]
assessment_id
continue
score
continue
score
continue
score
continue
score
Allocation.where(assessment_id: params[:assessment_id]).last.update
Allocation.where(assessment_id: params[:assessment_id])
continue
n
@assessment
continue
Allocation.where(assessment_id: 73)
@assessment
params
continue
request_body[:files]
continue
request_body[:files]
request_body[:stdin]
request_body[:language]
continue
response
response_body
continue
params[:language]
continue
params[:language]
params[:stdin]
params[:code]
params
response_body
continue
params[:code]
coding_question.content
coding_question.code
coding_question
continue
response
n
request.body
n
response
request_body[:language]
n
code
continue
params["code"]
params
continue
response.read_body
response
request.body
continue
request_body
request
code
http
url
c
continue
response.errors.full_messages
continue
ReplitCompilerService
replit_compiler = ReplitCompilerService.new(api_key)
language
code
api_key
continue
response.parsed_response['message']
n
continue
response.headers['Referer']
response.headers
response
n
response
continue
compiler
continue
response.parsed_response['message']
response.success?
response
responses
n
language
@api_key
n
compiler
continue
response.parsed_response
n
continue
response.parsed_response
response.errors
response
response.parsed_response
continue
response.parsed_response['message']
n
continue
response.parsed_response
n
continue
response.parsed_response
response.parsed_response['message']
n
continue
response.parsed_response['message']
n
continue
response.parsed_response['message']
response.parsed_response
response.errors.full_messages
response.errors
response.parsed_response['message']
response.success?
n
compiler
continue
response.parsed_response['message']
{response.parsed_response['message']
response.success?
n
code
language
n
compiler
continue
response.parsed_response['message']
n
c
response.parsed_response
n
c
response
response.json
response.data
response
respone
response.error
response.errors.full_messages
response.success?.error.full_messages
response.success?.errors.full_messages
n
continue
response.headers
response
n
self.class.post(language: )
@api_key
api_key
ReplitCompiler.methods
self.class
self
continue
response.success?
n
continue
response.success?
response.success
response.success?
response
n
code
language
continue
compiler.compile_code(language, code)
compiler
continue
response.success?
n
code
language
continue
compiler.compile_code(language, code)
compiler
code
language
language,
continue
Rails.logger.debug("Compiler result: #{result.inspect}")
compiler.compile_code(language, code)
compiler.compile_code
continue
ReplitCompiler.new(ENV["REPLIT_API_KEY"])
continue
ReplitCompiler.new(ENV["SECRETS_KEY"])
continue
ReplitCompiler.new(ENV["SECRETS_KEY"])
params
continue
ReplitCompiler.new(ENV["SECRETS_KEY"])
params
continue
params[:assessment_id]
@coding_question
continue
@coding_question
continue
@coding_question.save
@coding_question
coding_question_params
continue
@coding_question.save
@coding_question
continue
@coding_question
coding_question_params
continue
params
continue
Allocation.where(assessment_id: params[:assessment_id]).update(score: score)
Allocation.where(assessment_id: params[:assessment_id])
Allocation.find(params[:assessment_id])
Allocation
continue
correct_option
question
n
